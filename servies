#!/bin/bash

source "$(dirname "$(readlink -f "$BASH_SOURCE")")"/vendor/minond/debug/debug

ROUTE_URLS=()
ROUTE_METHODS=()
ROUTE_HANDLERS=()
DEBUG_ROUTER_COLOR="$RANDOM"

declare -A http_status_codes=(
    ["200"]="OK"
    ["404"]="Not found"
)

#=== FUNCTION =================================================================
#        NAME: pipe
# DESCRIPTION: create a fifo that acts as a pipe from a program to another
# PARAMETER 1: name of fifo file
#==============================================================================
pipe() {
    local name=$1
    mkfifo "$name"
    trap "rm -f '$name'" EXIT
}

#=== FUNCTION =================================================================
#        NAME: listen
# DESCRIPTION: makes netcat listen for a request
# PARAMETER 1: name of fifo file
# PARAMETER 2: listen on this host
# PARAMETER 2: listen on this port
#==============================================================================
listen() {
    local conn=$1
    local host=$2
    local port=$3

    debug server "listening for requests on $HOST:$PORT"

    while true; do
        cat "$conn" | netcat -l "$host" "$port" > >(
            local parsed=0
            local method=
            local url=

            # read every line from the request
            while read line; do
                line=$(echo "$line" | tr -d '\r\n')

                # if this is the first line, save the route information
                if [ "$parsed" -eq 0 ]; then
                    parsed=1
                    url=$(echo "$line" | sed -n 's/.* \(\/.*\) .*/\1/p')
                    method=$(echo "$line" | sed -n 's/\(.*\) .* .*/\1/p');
                fi

                # if the trimmed line is empty, we have parsed all the headers
                # and are moving into the body of the request. now we can start
                # working on the reponse.
                if [ "x$line" = "x" ]; then
                    route "$conn" "$method" "$url"

                    # do not care what the body includes. if we wanted to add
                    # body parsing, it would go here.
                    break
                fi
            done
        )

        debug:time_reset
    done
}

#=== FUNCTION =================================================================
#        NAME: route
# DESCRIPTION: find a request handler and call the action
# PARAMETER 1: name of fifo file
# PARAMETER 2: http method
# PARAMETER 3: url
#==============================================================================
route() {
    local action=
    local values=
    local groups=

    local conn=$1
    local method=$2
    local url=$3

    for ((i=0;i<${#ROUTE_METHODS[@]};i++)) do
        route_matches_index "$i" "$method" "$url"
        if [ $? -eq 0 ]; then
            values=$(echo "$url" | sed -E "${ROUTE_EXTRACTOR[$i]}")
            groups="${ROUTE_GROUPS[$i]}"

            # cast to array. better way to do this??
            groups=( $groups )
            values=( $values )

            action="${ROUTE_HANDLERS[$i]}"
            break
        fi
    done

    # declare all matches in the local scope. perhaps there's a way to do this
    # so it doesn't muck up this function's scope.
    for i in $(seq 0 $(echo "$groups" | wc -w)); do
        local group="${groups[$i]}"
        local value="${values[$i]}"

        [ -z "$group" ] && continue

        eval "local $group=$value"
    done

    [ -z "$action" ] && action=not_found
    debug:set_color router "$DEBUG_ROUTER_COLOR"
    debug router "routing $method $url to $action"
    eval "$action" > "$conn"
}

#=== FUNCTION =================================================================
#        NAME: route_matches_index
# DESCRIPTION: given a url and a request method, and also the index of the
#              routes array of the route in question, this will check if
#              the route in question can be used to handle the request
# PARAMETER 1: index of the routes array to check
# PARAMETER 2: request method
# PARAMETER 3: url
#==============================================================================
route_matches_index() {
    local i="$1"
    local method="$2"
    local url="$3"

    if [ "${ROUTE_METHODS[$i]}" = "$method" ]; then
        echo "$url" | grep -e "${ROUTE_PATTERN[$i]}" &> /dev/null
    else
        false
    fi
}

#=== FUNCTION =================================================================
#        NAME: status
# DESCRIPTION: output a header
# PARAMETER 1: header name
# PARAMETER 2: header value
#==============================================================================
status() {
    local code=$1
    local name=$2

    [ -z "$name" ] && name="${http_status_codes[$code]}"

    echo HTTP/1.1 "$code" "$name"
}

#=== FUNCTION =================================================================
#        NAME: header
# DESCRIPTION: output a header
# PARAMETER 1: header name
# PARAMETER 2: header value
#==============================================================================
header() {
    echo "$1: $2"
}

#=== FUNCTION =================================================================
#        NAME: go
# DESCRIPTION: start a server
#==============================================================================
go() {
    [ -z "$PORT" ] && PORT=8080
    [ -z "$HOST" ] && HOST=0.0.0.0
    pipe "conn"
    listen "conn" "$HOST" "$PORT"
}

#=== FUNCTION =================================================================
#        NAME: not_found
# DESCRIPTION: default not found handler. overwrite for custom output
#==============================================================================
not_found() {
    echo HTTP/1.1 404 Not Found
    echo Content-Type: text/plain
    echo
    echo 404, Not found
}

#=== FUNCTION =================================================================
#        NAME: url_pattern
# DESCRIPTION: converts a human-friendly url into a string you can use as a
#              match expression
# PARAMETER 1: the url you want to convert into an expression
#==============================================================================
url_pattern() {
    local pattern=$(echo "$1" | \
        # make slashes optional: /welcome/ => \/?welcome\/?
        sed 's/\//\/?/g' | \
        # replace human groups with regex groups: /welcome/:name => /welcome/\w\+
        sed -E 's/:(\w*)/\\w\\+/g' | \
        # replace question makes with optional group match expressions:
        # /welcome/:name => /welcome/\w\+\?
        sed 's/?/\\?/g')

    echo "^${pattern}$"
}

#=== FUNCTION =================================================================
#        NAME: url_extractor
# DESCRIPTION: converts a human-friendly url into a sed match and replace
#              expression that can be used to extract match values
# PARAMETER 1: the url you want to convert into an expression
#==============================================================================
url_extractor() {
    local url="$1"
    local groups=$(echo $(url_groups "$url") | wc -w)

    local replace=
    local search=$(echo "$url" | \
        # escape forward slashes
        sed 's/\//\\\//g' | \
        # optional forward slashes
        sed 's/\//\/{0,}/g' | \
        # replace groups with work matching expression
        sed -E 's/:(\w*)/(\\w\+)/g' | \
        # replace question marks with regex expression for optional matches
        sed 's/?/{0,}/g')

    if [ "$groups" -ne 0 ]; then
        for i in $(seq 1 "$groups"); do
            replace="$replace \\$i"
        done
    fi

    echo "s/$search/$replace/"
}

#=== FUNCTION =================================================================
#        NAME: url_groups
# DESCRIPTION: searches a url for groups (:group_name)
# PARAMETER 1: the url you want to get groups from
#==============================================================================
url_groups() {
    echo $(echo "$1" | \
        grep -o -e ':\w\+' | \
        grep -o -e '\w\+')
}

#=== FUNCTION =================================================================
#        NAME: save_route
# DESCRIPTION: add a new route
# PARAMETER 1: method
# PARAMETER 2: url string (include first forward slash)
# PARAMETER 3: command name
#==============================================================================
save_route() {
    local method=$1
    local url=$2
    shift
    shift
    local handler="$*"

    ROUTE_PATTERN+=("$(url_pattern "$url")")
    ROUTE_EXTRACTOR+=("$(url_extractor "$url")")
    ROUTE_GROUPS+=("$(url_groups "$url")")
    ROUTE_URLS+=("$url")
    ROUTE_METHODS+=("$method")
    ROUTE_HANDLERS+=("$handler")

    debug route "creating route: $method $url"
}

#=== FUNCTION =================================================================
#        NAME: get
# DESCRIPTION: add a get route handler
# PARAMETER 1: url string (include first forward slash)
# PARAMETER 2: command name
#==============================================================================
get() {
    save_route GET "$@"
}

#=== FUNCTION =================================================================
#        NAME: post
# DESCRIPTION: add a post route handler
# PARAMETER 1: url string (include first forward slash)
# PARAMETER 2: command name
#==============================================================================
post() {
    save_route POST "$@"
}

#=== FUNCTION =================================================================
#        NAME: put
# DESCRIPTION: add a put route handler
# PARAMETER 1: url string (include first forward slash)
# PARAMETER 2: command name
#==============================================================================
put() {
    save_route PUT "$@"
}

#=== FUNCTION =================================================================
#        NAME: patch
# DESCRIPTION: add a patch route handler
# PARAMETER 1: url string (include first forward slash)
# PARAMETER 2: command name
#==============================================================================
patch() {
    save_route PATCH "$@"
}

# running as command?
if [ ! -z "$1" ]; then
    source "$1"
    go
fi
